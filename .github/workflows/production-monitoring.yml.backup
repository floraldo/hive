name: 🛡️ Production Shield Monitoring

on:
  schedule:
    # Run every 5 minutes for proactive monitoring
    - cron: '*/5 * * * *'
  workflow_dispatch:
    # Allow manual triggering for testing
    inputs:
      environment:
        description: 'Environment to monitor (production, staging, all)'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - production
        - staging

permissions:
  contents: read
  issues: write

jobs:
  production-monitoring:
    runs-on: ubuntu-latest
    name: Production Health Monitoring

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests pydantic

    - name: Run production health monitoring
      id: monitoring
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        # Production monitoring secrets (to be configured)
        PRODUCTION_ENDPOINTS: ${{ secrets.PRODUCTION_ENDPOINTS }}
        STAGING_ENDPOINTS: ${{ secrets.STAGING_ENDPOINTS }}
        MONITORING_WEBHOOK: ${{ secrets.MONITORING_WEBHOOK }}
      run: |
        python scripts/operational_excellence/production_monitor.py \
          --environment ${{ github.event.inputs.environment || 'all' }} \
          --create-incidents

    - name: Create incident issue for failures
      if: steps.monitoring.outputs.has_failures == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Read monitoring results
          let monitoringResults = {};
          try {
            const resultsContent = fs.readFileSync('production_monitoring_results.json', 'utf8');
            monitoringResults = JSON.parse(resultsContent);
          } catch (error) {
            console.log('No monitoring results file found');
            return;
          }

          if (!monitoringResults.failures || monitoringResults.failures.length === 0) {
            return;
          }

          // Create incident issue
          const timestamp = new Date().toISOString();
          const failureCount = monitoringResults.failures.length;

          let issueBody = `# 🚨 Production Health Incident

          **Incident Detected**: ${timestamp}
          **Affected Services**: ${failureCount}
          **Monitoring Run**: Automated Production Shield

          ## 🔍 Failure Details

          `;

          monitoringResults.failures.forEach((failure, index) => {
            issueBody += `### ${index + 1}. ${failure.service_name}

          - **Endpoint**: \`${failure.endpoint}\`
          - **Status**: ${failure.status_code || 'Connection Failed'}
          - **Response Time**: ${failure.response_time_ms || 'N/A'}ms
          - **Error**: ${failure.error_message}
          - **Environment**: ${failure.environment}
          - **Detected At**: ${failure.timestamp}

          `;
          });

          issueBody += `
          ## 🎯 Immediate Actions Required

          1. **Investigate** the failing services immediately
          2. **Check logs** for error patterns and root cause
          3. **Verify infrastructure** status (servers, databases, networks)
          4. **Update this issue** with investigation findings
          5. **Close this issue** once all services are healthy

          ## 📊 Health Summary

          - **Total Endpoints Monitored**: ${monitoringResults.total_endpoints}
          - **Healthy Services**: ${monitoringResults.healthy_count}
          - **Failed Services**: ${monitoringResults.failed_count}
          - **Success Rate**: ${monitoringResults.success_rate}%

          ---

          **Auto-generated by Production Shield Monitoring**
          **Next Check**: In 5 minutes

          @${context.repo.owner} - Production incident requires immediate attention!`;

          // Look for existing open incident
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: ['incident', 'production', 'automated'],
            state: 'open'
          });

          if (existingIssues.data.length > 0) {
            // Update existing incident
            const issue = existingIssues.data[0];
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## 🔄 Incident Update - ${new Date().toLocaleString()}

              **Status**: Still detecting failures
              **Failed Services**: ${failureCount}

              ${monitoringResults.failures.map(f => `- ${f.service_name}: ${f.error_message}`).join('\n')}

              **Action Required**: Investigation and resolution needed.`
            });
          } else {
            // Create new incident
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🚨 Production Health Incident - ${failureCount} Service(s) Down`,
              body: issueBody,
              labels: ['incident', 'production', 'automated', 'urgent'],
              assignees: [context.repo.owner]
            });
          }

    - name: Update healthy status
      if: steps.monitoring.outputs.has_failures == 'false' && steps.monitoring.outputs.all_healthy == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          // Close any open incident issues if all services are healthy
          const openIncidents = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: ['incident', 'production', 'automated'],
            state: 'open'
          });

          for (const issue of openIncidents.data) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## ✅ Incident Resolved - ${new Date().toLocaleString()}

              **Status**: All services are now healthy
              **Resolution**: Automatic recovery detected

              This incident is being automatically closed as all monitored services are responding normally.

              **Next Steps**: Review logs to understand the root cause and prevent recurrence.`
            });

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed',
              labels: [...issue.labels.map(l => l.name), 'resolved']
            });
          }

    - name: Upload monitoring results
      uses: actions/upload-artifact@v4
      with:
        name: production-monitoring-results
        path: production_monitoring_results.json
        retention-days: 7
