#!/usr/bin/env python3
"""
Smoke Test Generator for Hive Platform

Automatically generates basic import tests for all Python modules
to catch syntax errors and import issues early.

Usage:
    python scripts/generate_smoke_tests.py
    python scripts/generate_smoke_tests.py --dry-run
    python scripts/generate_smoke_tests.py --package hive-async
"""

from __future__ import annotations

import argparse
import ast
import sys
from pathlib import Path
from typing import Any

# Add hive packages to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root / "packages" / "hive-logging" / "src"))

from hive_logging import get_logger

logger = get_logger(__name__)


def find_python_modules(package_path: Path) -> list[dict[str, Any]]:
    """
    Find all Python modules in a package.

    Args:
        package_path: Path to package (e.g., packages/hive-async)

    Returns:
        List of module info dicts with 'path', 'module_name', 'import_path'
    """
    modules = []
    src_path = package_path / "src"

    if not src_path.exists():
        logger.warning(f"No src/ directory found in {package_path.name}")
        return modules

    for py_file in src_path.rglob("*.py"):
        # Skip __pycache__ and other non-module files
        if "__pycache__" in str(py_file) or py_file.name.startswith("."):
            continue

        # Skip __init__.py for now (tested via package import)
        if py_file.name == "__init__.py":
            continue

        # Calculate import path
        relative = py_file.relative_to(src_path)
        import_parts = list(relative.parts[:-1]) + [relative.stem]
        import_path = ".".join(import_parts)

        modules.append(
            {"path": py_file, "module_name": py_file.stem, "import_path": import_path},
        )

    return modules


def check_module_has_exports(module_path: Path) -> list[str]:
    """
    Check if module has public exports (classes, functions).

    Args:
        module_path: Path to Python file

    Returns:
        List of public export names
    """
    try:
        with open(module_path) as f:
            tree = ast.parse(f.read())

        exports = []
        for node in ast.walk(tree):
            # Find classes and functions that don't start with _
            if isinstance(node, ast.ClassDef) and not node.name.startswith("_"):
                exports.append(node.name)
            elif isinstance(node, ast.FunctionDef) and not node.name.startswith("_"):
                exports.append(node.name)

        return exports

    except Exception as e:
        logger.warning(f"Failed to parse {module_path.name}: {e}")
        return []


def generate_smoke_test(package_name: str, modules: list[dict[str, Any]]) -> str:
    """
    Generate smoke test file content for a package.

    Args:
        package_name: Name of package (e.g., 'hive-async')
        modules: List of module info dicts

    Returns:
        Python code for smoke test file
    """
    test_functions = []

    for module in modules:
        import_path = module["import_path"]
        module_name = module["module_name"]

        # Check if module has public exports
        exports = check_module_has_exports(module["path"])

        if exports:
            # Generate test that imports and checks key exports
            test_func = f"""
def test_{module_name}_imports():
    \"\"\"Smoke test: {module_name} module imports successfully.\"\"\"
    from {import_path} import {exports[0]}
    assert {exports[0]} is not None
"""
        else:
            # Generate basic import test
            test_func = f"""
def test_{module_name}_imports():
    \"\"\"Smoke test: {module_name} module imports successfully.\"\"\"
    import {import_path}
    assert {import_path} is not None
"""

        test_functions.append(test_func)

    # Combine into complete test file
    header = f'''"""
Smoke tests for {package_name} package.

Auto-generated by scripts/generate_smoke_tests.py
These tests ensure all modules can be imported without errors.
"""

from __future__ import annotations

import pytest
'''

    return header + "\n".join(test_functions)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Generate smoke tests for Hive packages")

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be generated without writing files",
    )

    parser.add_argument(
        "--package",
        type=str,
        help="Generate for specific package only (e.g., hive-async)",
    )

    parser.add_argument(
        "--output-dir",
        type=str,
        default="tests/smoke",
        help="Output directory for smoke tests (default: tests/smoke)",
    )

    args = parser.parse_args()

    # Find all packages
    packages_dir = project_root / "packages"

    if args.package:
        package_paths = [packages_dir / args.package]
    else:
        package_paths = [p for p in packages_dir.iterdir() if p.is_dir() and not p.name.startswith(".")]

    logger.info(f"Generating smoke tests for {len(package_paths)} packages...")

    for package_path in package_paths:
        package_name = package_path.name
        logger.info(f"\nProcessing {package_name}...")

        # Find modules
        modules = find_python_modules(package_path)

        if not modules:
            logger.warning(f"  No modules found in {package_name}")
            continue

        logger.info(f"  Found {len(modules)} modules")

        # Generate smoke test
        test_content = generate_smoke_test(package_name, modules)

        # Determine output path
        output_file = package_path / args.output_dir / f"test_smoke_{package_name.replace('-', '_')}.py"

        if args.dry_run:
            logger.info(f"  Would write to: {output_file}")
            logger.info("  Preview (first 500 chars):")
            logger.info(f"  {test_content[:500]}")
        else:
            # Create output directory
            output_file.parent.mkdir(parents=True, exist_ok=True)

            # Write test file
            with open(output_file, "w") as f:
                f.write(test_content)

            logger.info(f"  Created: {output_file}")

    if args.dry_run:
        logger.info("\n=== DRY RUN - No files written ===")
    else:
        logger.info("\n=== SUCCESS - Smoke tests generated ===")
        logger.info(f"Run tests with: pytest {args.output_dir}")


if __name__ == "__main__":
    main()
