"""Base Component Class with DRY Parameter Management.

This module provides the refactored base Component class with automatic
parameter unpacking to eliminate repetitive initialization code.
"""
import cvxpy as cp
import numpy as np
from typing import Dict, Any, Optional, List
from pydantic import BaseModel
import logging

logger = logging.getLogger(__name__)


class Component:
    """Base class for all system components with automatic DRY parameter handling."""

    # Class attribute for parameter model (override in subclasses)
    PARAMS_MODEL = BaseModel

    def __init__(self, name: str, params: BaseModel, n: int = 24):
        """Initialize component with automatic parameter unpacking.

        This constructor implements the DRY principle by automatically unpacking
        all Pydantic model parameters as instance attributes, eliminating the need
        for repetitive self.X = params.X code in every component.

        Args:
            name: Component identifier
            params: Pydantic BaseModel containing all parameters
            n: Number of timesteps
        """
        self.name = name
        self.params = params  # Store full params object
        self.N = n

        # Initialize standard component attributes
        self.type = "base"  # Will be overridden in _post_init
        self.medium = "electricity"  # Will be overridden in _post_init

        # Flow dictionaries for system connections
        self.flows = {
            'input': {},    # Incoming flows from other components
            'output': {},   # Outgoing flows to other components
            'source': {},   # Flows generated by this component
            'sink': {}      # Flows consumed by this component
        }

        # Constraints list for optimization
        self.constraints = []
        self.profile = None

        # --- AUTOMATIC DRY PARAMETER UNPACKING ---
        # Unpack all fields from the Pydantic model as top-level attributes
        # This eliminates repetitive initialization code in subclasses
        for field_name, value in params.dict().items():
            if value is not None:
                setattr(self, field_name, value)
                logger.debug(f"{name}: Auto-unpacked {field_name}")

        # Call component-specific initialization
        # Subclasses override this instead of __init__
        self._post_init()

    def _post_init(self):
        """Override in subclasses for component-specific initialization.

        This method is called after automatic parameter unpacking.
        Use it to:
        - Set component type and medium
        - Calculate derived values
        - Initialize component-specific attributes

        DO NOT unpack parameters here - that's done automatically!
        """
        pass

    @classmethod
    def get_params_model(cls):
        """Get the Pydantic model class for this component's parameters.

        Override in subclasses to specify the correct params model.

        Returns:
            The Pydantic BaseModel class for parameters
        """
        return cls.PARAMS_MODEL

    def add_optimization_vars(self, N: int):
        """Create CVXPY optimization variables for this component.

        Override in subclasses that have optimization variables.

        Args:
            N: Number of time steps
        """
        pass

    def set_constraints(self) -> List:
        """Define CVXPY constraints for this component.

        Override in subclasses to define component-specific constraints.

        Returns:
            List of CVXPY constraints
        """
        return self.constraints

    def validate_parameters(self) -> bool:
        """Validate component parameters for consistency.

        Override in subclasses for component-specific validation.

        Returns:
            True if parameters are valid
        """
        return True

    def get_info(self) -> Dict[str, Any]:
        """Get component information as a dictionary.

        Returns:
            Dictionary containing component information
        """
        return {
            'name': self.name,
            'type': self.type,
            'medium': self.medium,
            'parameters': self.params.dict() if self.params else {},
            'has_profile': self.profile is not None,
            'class': self.__class__.__name__
        }

    def get_state_at_timestep(self, t: int) -> Dict[str, float]:
        """Get component state at specific timestep.

        Args:
            t: Timestep index

        Returns:
            Dictionary with state information
        """
        state = {
            'name': self.name,
            'type': self.type,
            'medium': self.medium
        }

        # Add profile value if available
        if self.profile is not None and t < len(self.profile):
            state['profile_value'] = float(self.profile[t])

        return state

    def __str__(self) -> str:
        """String representation of the component."""
        return f"{self.__class__.__name__}('{self.name}', type={self.type}, medium={self.medium})"

    def __repr__(self) -> str:
        """Detailed representation of the component."""
        return f"{self.__class__.__name__}(name='{self.name}', type='{self.type}', params={self.params})"