#!/usr/bin/env python3
"""
Comprehensive tests for Dijkstra's algorithm implementation

Generated by Hive Autonomous AI Agents for Factory Acceptance Testing.
Tests cover correctness, edge cases, performance, and error handling.
"""

from math import inf

import pytest

# Use proper Poetry workspace imports instead of sys.path hacks
from hive_algorithms import Edge, Graph, dijkstra, find_shortest_path


class TestGraph:
    """Test graph data structure"""

    def test_empty_graph(self):
        """Test empty graph creation"""
        g = Graph()
        assert len(g.get_vertices()) == 0

    def test_add_vertex(self):
        """Test vertex addition"""
        g = Graph()
        g.add_vertex("A")
        assert g.has_vertex("A")
        assert "A" in g.get_vertices()

    def test_add_edge(self):
        """Test edge addition"""
        g = Graph()
        g.add_edge("A", "B", 5.0)

        assert g.has_vertex("A")
        assert g.has_vertex("B")

        neighbors = g.get_neighbors("A")
        assert len(neighbors) == 1
        assert neighbors[0].destination == "B"
        assert neighbors[0].weight == 5.0

    def test_negative_weight_rejection(self):
        """Test that negative weights are rejected"""
        g = Graph()

        with pytest.raises(ValueError, match="non-negative"):
            g.add_edge("A", "B", -1.0)

    def test_edge_negative_weight_rejection(self):
        """Test Edge class rejects negative weights"""
        with pytest.raises(ValueError, match="non-negative"):
            Edge("B", -1.0)


class TestDijkstraAlgorithm:
    """Test Dijkstra's algorithm correctness"""

    def create_simple_graph(self):
        """Create a simple test graph"""
        g = Graph()
        g.add_edge("A", "B", 4)
        g.add_edge("A", "C", 2)
        g.add_edge("B", "C", 1)
        g.add_edge("B", "D", 5)
        g.add_edge("C", "D", 8)
        g.add_edge("C", "E", 10)
        g.add_edge("D", "E", 2)
        return g

    def test_simple_shortest_paths(self):
        """Test shortest paths in simple graph"""
        g = self.create_simple_graph()
        result = dijkstra(g, "A")

        # Expected shortest distances from A (directed graph)
        expected_distances = {
            "A": 0,
            "B": 4,  # A -> B (direct)
            "C": 2,  # A -> C (direct)
            "D": 9,  # A -> B -> D (4 + 5)
            "E": 11,  # A -> B -> D -> E (4 + 5 + 2)
        }

        for vertex, expected_dist in expected_distances.items():
            assert result.get_distance(vertex) == expected_dist

    def test_shortest_path_reconstruction(self):
        """Test path reconstruction"""
        g = self.create_simple_graph()
        result = dijkstra(g, "A")

        # Test path to E (directed graph)
        path_to_e = result.get_shortest_path("E")
        expected_path = ["A", "B", "D", "E"]
        assert path_to_e == expected_path

        # Test path to source
        path_to_a = result.get_shortest_path("A")
        assert path_to_a == ["A"]

    def test_unreachable_vertex(self):
        """Test handling of unreachable vertices"""
        g = Graph()
        g.add_edge("A", "B", 1)
        g.add_vertex("C")  # Isolated vertex

        result = dijkstra(g, "A")

        # C should be unreachable
        assert result.get_distance("C") == inf
        assert result.get_shortest_path("C") is None

    def test_single_vertex_graph(self):
        """Test graph with single vertex"""
        g = Graph()
        g.add_vertex("A")

        result = dijkstra(g, "A")
        assert result.get_distance("A") == 0
        assert result.get_shortest_path("A") == ["A"]

    def test_invalid_source_vertex(self):
        """Test error handling for invalid source vertex"""
        g = Graph()
        g.add_edge("A", "B", 1)

        with pytest.raises(ValueError, match="does not exist"):
            dijkstra(g, "Z")

    def test_zero_weight_edges(self):
        """Test handling of zero-weight edges"""
        g = Graph()
        g.add_edge("A", "B", 0)
        g.add_edge("B", "C", 1)

        result = dijkstra(g, "A")
        assert result.get_distance("B") == 0
        assert result.get_distance("C") == 1

    def test_self_loops(self):
        """Test handling of self-loops"""
        g = Graph()
        g.add_edge("A", "A", 5)  # Self-loop
        g.add_edge("A", "B", 1)

        result = dijkstra(g, "A")
        assert result.get_distance("A") == 0  # Self-loop shouldn't affect source
        assert result.get_distance("B") == 1

    def test_disconnected_components(self):
        """Test handling of disconnected graph components"""
        g = Graph()
        # Component 1
        g.add_edge("A", "B", 1)
        # Component 2 (disconnected)
        g.add_edge("C", "D", 1)

        result = dijkstra(g, "A")
        assert result.get_distance("B") == 1
        assert result.get_distance("C") == inf
        assert result.get_distance("D") == inf


class TestConvenienceFunction:
    """Test the convenience function"""

    def test_find_shortest_path_function(self):
        """Test find_shortest_path convenience function"""
        g = Graph()
        g.add_edge("A", "B", 3)
        g.add_edge("A", "C", 1)
        g.add_edge("C", "B", 1)

        path, distance = find_shortest_path(g, "A", "B")

        assert distance == 2
        assert path == ["A", "C", "B"]

    def test_find_shortest_path_unreachable(self):
        """Test convenience function with unreachable destination"""
        g = Graph()
        g.add_edge("A", "B", 1)
        g.add_vertex("C")  # Isolated

        path, distance = find_shortest_path(g, "A", "C")

        assert distance == inf
        assert path is None


class TestPerformance:
    """Test algorithm performance characteristics"""

    def test_large_graph_performance(self):
        """Test performance on larger graph"""
        g = Graph()

        # Create a larger graph (100 vertices)
        for i in range(100):
            for j in range(min(5, 100 - i)):  # Each vertex connects to next 5
                if i + j + 1 < 100:
                    g.add_edge(f"v{i}", f"v{i + j + 1}", j + 1)

        # This should complete quickly
        import time

        start = time.time()
        result = dijkstra(g, "v0")
        duration = time.time() - start

        # Should complete in under 1 second for this size
        assert duration < 1.0
        assert result.get_distance("v0") == 0

    def test_dense_graph(self):
        """Test algorithm on dense graph"""
        g = Graph()

        # Create complete graph with 20 vertices
        vertices = [f"v{i}" for i in range(20)]

        for i in vertices:
            for j in vertices:
                if i != j:
                    # Use hash of vertex names for consistent weights
                    weight = abs(hash(i + j)) % 10 + 1
                    g.add_edge(i, j, weight)

        result = dijkstra(g, "v0")

        # All vertices should be reachable
        for vertex in vertices:
            assert result.get_distance(vertex) < inf


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
