from __future__ import annotations

#!/usr/bin/env python3
"""
Dijkstra's Shortest Path Algorithm Implementation

Generated by Hive Autonomous AI Agents for Factory Acceptance Testing.
This implementation provides efficient shortest path calculation in weighted graphs.
"""


import heapq
from dataclasses import dataclass
from typing import Dict, Tuple

# Use hive-logging for consistent logging
from hive_logging import get_logger

logger = get_logger(__name__)


@dataclass
class Edge:
    """Represents a weighted edge in the graph"""

    destination: str
    weight: float

    def __post_init__(self) -> None:
        if self.weight < 0:
            raise ValueError("Edge weights must be non-negative for Dijkstra's algorithm")


class Graph:
    """
    Weighted directed graph implementation optimized for Dijkstra's algorithm.

    Uses adjacency list representation for efficient neighbor lookup.
    """

    def __init__(self) -> None:
        self._adjacency_list: Dict[str, List[Edge]] = {}

    def add_vertex(self, vertex: str) -> None:
        """Add a vertex to the graph"""
        if vertex not in self._adjacency_list:
            self._adjacency_list[vertex] = []

    def add_edge(self, source: str, destination: str, weight: float) -> None:
        """Add a weighted edge to the graph"""
        if weight < 0:
            raise ValueError("Dijkstra's algorithm requires non-negative edge weights")

        self.add_vertex(source)
        self.add_vertex(destination)

        self._adjacency_list[source].append(Edge(destination, weight))

    def get_neighbors(self, vertex: str) -> List[Edge]:
        """Get all neighbors of a vertex"""
        return self._adjacency_list.get(vertex, [])

    def get_vertices(self) -> Set[str]:
        """Get all vertices in the graph"""
        return set(self._adjacency_list.keys())

    def has_vertex(self, vertex: str) -> bool:
        """Check if vertex exists in graph"""
        return vertex in self._adjacency_list


@dataclass
class DijkstraResult:
    """Result of Dijkstra's algorithm execution"""

    distances: Dict[str, float]
    previous: Dict[str, str | None]
    source: str

    def get_shortest_path(self, destination: str) -> Optional[List[str]]:
        """
        Reconstruct the shortest path from source to destination.

        Args:
            destination: Target vertex

        Returns:
            List of vertices representing the shortest path, or None if unreachable
        """
        if destination not in self.distances:
            return None

        if self.distances[destination] == float("inf"):
            return None  # Destination is unreachable

        path = []
        current = destination

        while current is not None:
            path.append(current)
            current = self.previous[current]

        return list(reversed(path))

    def get_distance(self, destination: str) -> float:
        """Get shortest distance to destination"""
        return self.distances.get(destination, float("inf"))


def dijkstra(graph: Graph, source: str) -> DijkstraResult:
    """
    Implement Dijkstra's shortest path algorithm.

    Args:
        graph: Weighted graph to analyze
        source: Starting vertex

    Returns:
        DijkstraResult containing distances and paths

    Raises:
        ValueError: If source vertex doesn't exist in graph

    Time Complexity: O((V + E) log V) where V is vertices and E is edges
    Space Complexity: O(V)
    """
    if not graph.has_vertex(source):
        raise ValueError(f"Source vertex '{source}' does not exist in graph")

    # Initialize distances and previous vertex tracking
    distances: Dict[str, float] = {}
    previous: Dict[str, str | None] = {}
    visited: Set[str] = set()

    # Initialize all distances to infinity
    for vertex in graph.get_vertices():
        distances[vertex] = float("inf")
        previous[vertex] = None

    # Distance to source is 0
    distances[source] = 0

    # Priority queue: (distance, vertex)
    # Using negative distances to simulate min-heap behavior
    pq: List[Tuple[float, str]] = [(0, source)]
    heapq.heapify(pq)

    while pq:
        current_distance, current_vertex = heapq.heappop(pq)

        # Skip if we've already processed this vertex with a better distance
        if current_vertex in visited:
            continue

        # Mark as visited
        visited.add(current_vertex)

        # Check all neighbors
        for edge in graph.get_neighbors(current_vertex):
            neighbor = edge.destination
            weight = edge.weight

            # Skip if already visited
            if neighbor in visited:
                continue

            # Calculate new distance
            new_distance = distances[current_vertex] + weight

            # Update if we found a shorter path
            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (new_distance, neighbor))

    return DijkstraResult(distances, previous, source)


def find_shortest_path(graph: Graph, source: str, destination: str) -> Tuple[Optional[List[str]], float]:
    """
    Convenience function to find shortest path between two vertices.

    Args:
        graph: Weighted graph
        source: Starting vertex
        destination: Target vertex

    Returns:
        Tuple of (path_list, distance). Path is None if unreachable.
    """
    result = dijkstra(graph, source)
    path = result.get_shortest_path(destination)
    distance = result.get_distance(destination)

    return path, distance


# Example usage and validation
if __name__ == "__main__":
    # Create a test graph
    g = Graph()

    # Add edges for a simple test case
    g.add_edge("A", "B", 4)
    g.add_edge("A", "C", 2)
    g.add_edge("B", "C", 1)
    g.add_edge("B", "D", 5)
    g.add_edge("C", "D", 8)
    g.add_edge("C", "E", 10)
    g.add_edge("D", "E", 2)

    # Find shortest paths from A
    result = dijkstra(g, "A")

    logger.info("Shortest distances from A:")
    for vertex in ["A", "B", "C", "D", "E"]:
        distance = result.get_distance(vertex)
        path = result.get_shortest_path(vertex)
        logger.info(f"  {vertex}: {distance} (path: {' -> '.join(path) if path else 'unreachable'})")
